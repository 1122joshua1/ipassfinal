/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.


*/

#include<array>
#include "hwlib.hpp"


#ifndef DMX_HPP
#define DMX_HPP







/**

\brief
implements the lixada 25w moving head beam light

the class moving is a class which is made to seamlessly intergrate the lixada 25w beam moving head light.
it has the channle proofile of this fixture already built in , it also has a way to interface with the fixture using 1 button and 1 potentiometer


*/
class moving{									
friend class dmx512;
private:
	bool operator==(const int &rhs); ///<when comparing a moving type object with an int using == the start addres wil be used for the moving type object
	// *pan *tilt *color gobo shutter *dimmer speed control dimmmode
	int waardes[4] = {0,128,255,0};
	int constanten[5] = {60, 10, 10, 0, 0};
	int adressen[9] = {waardes[0], waardes[1], waardes[3], constanten[0], constanten[1], waardes[2], constanten[2],constanten[3],constanten[4]};/// the adresses the fixture occupies and thier values
	int lengte =9;///<how many adresses the fixture occupies
	int currel=0;///<the current element being edited by changecurr
	int startdres =0;///<the starting adres; the first addres of the fixture

public:
void nextelement();///<this cycles trough the values which can be edited using changecur

/**
\brief
edit currently selected field

edit the field selected with nextelement. waarde should be positive and no more than 255
*/
void changecur(int waarde);

void sendstream(int pan, int tilt, int color, int dim);///<alows you to send pan, tilt, color and dim values which will override the current values stored in the object
void strobestart();///<starts strobing the light. will reset any set value in field 4(shutter)
void strobestop();///<stops strobing the light will. reset any set value in field 4(shutter)

};



/**

\brief
implements the hardware USART for dmx and implements fixture patching


the dmx512 class implements all the hardware functions to correctly use a max485 chip to communicate with dmx capable fixtures. it uses the hardware USART0 on the arduino Due for this, at a baudrate
of 250Kbaud

primary usage is by telling it on which channels you have fixtures, and then updating the fixtures, when used in this way, make shure to call fixtureout() atleast once a second, as this is what actually
puts data on the bus and the dmx specefecation specifies at least 1 packet per second


*/




class dmx512{



private:
Usart * hw_usart = USART0;


void usart_init(); ///<turns on and configures the hardware USART

bool usart_char_available(); ///<untested function for input

char usart_getc(); ///<untested function for input

void dmx_putc( char c );///<sends the given character as raw data to the dmx output, not timed for dmx use
void dmx_break(int waittime);///<sends a break,of the time given in its parameter, in microseconds) which is needed at the start of each packet
void dmx_startbyte();///<sends a startbyte (a normal byte wit value 0)
void dmx_sendbyte(char c);///<sends a byte of data to the dmx line, timed for dmx use


public:
	
	dmx512(bool mode);///<mode is reserved for future implementation, use 0 for now
	/**
	\brief
	send an array of ints over dmx

	the ints wil be sent, with the position in the array determening the adress[0 being adress 1]; each int shall be positve and no higher then 255, as dmx is an 8 bit standard and thus only accepts values up to 255, the int grootte tells the program how many bytes you want to send out. you may not send out  more then 512 bytes in one packet.
	*/
	void senddata(std::array<int, 512> data, int grootte);
	void fixtureout();///<output the values stored in the patched fixtures over the dmx
	int addtopatch(moving lamp, int start);///<add a fixture to the patch, returns the id which from hereonafter will be used to identify the fixure in te patch
	void updatefixture(moving lamp, int number);///<overrides the fixture of the given id, usually used to get new data into the fixture

private:
	bool mode;///<for future implementation of multiple output modes
	std::array<int,512> patch;///<holds 512 bytes,this is used to store the starting adresses of the fixtures in the array fixtures
	std::array<moving, 5> fixtures;///<holds the data of the fixtures
	int nfix=0;///<keeps track of how many fixtures we have patched
};






#endif












      








